<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="blocknote-bundle.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    #editor-container { width: 100%; height: 100%; overflow-y: auto; }
    #root { width: 100%; }
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #888;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
    }

    /* Notion-style typography overrides */
    .bn-container {
      --bn-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
    }

    .bn-editor {
      font-size: 14px;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    /* Heading sizes: compact Notion-like scale */
    [data-content-type=heading]                 { --level: 1.6em !important; }
    [data-content-type=heading][data-level="2"] { --level: 1.45em !important; }
    [data-content-type=heading][data-level="3"] { --level: 1.25em !important; }
    [data-content-type=heading][data-level="4"] { --level: 1em !important; }
    [data-content-type=heading][data-level="5"] { --level: 0.95em !important; }
    [data-content-type=heading][data-level="6"] { --level: 0.875em !important; }

    /* Tighter heading line-height + top padding for visual separation */
    .bn-block-content[data-content-type=heading] {
      line-height: 1.3;
      letter-spacing: -0.01em;
      padding-top: 0.6em;
    }

    /* Side menu heights to match smaller headings */
    .bn-side-menu[data-block-type=heading][data-level="1"] { height: 36px !important; }
    .bn-side-menu[data-block-type=heading][data-level="2"] { height: 30px !important; }
    .bn-side-menu[data-block-type=heading][data-level="3"] { height: 26px !important; }

    /* Ghostty theme integration: background/text sync */
    body.ghostty-themed { background: var(--ghostty-bg); color: var(--ghostty-fg); }
    body.ghostty-themed .bn-container {
      --bn-colors-editor-text: var(--ghostty-fg) !important;
      --bn-colors-editor-background: var(--ghostty-bg) !important;
      --bn-colors-menu-text: var(--ghostty-fg) !important;
      --bn-colors-menu-background: var(--ghostty-menu-bg) !important;
      --bn-colors-tooltip-text: var(--ghostty-fg) !important;
      --bn-colors-tooltip-background: var(--ghostty-menu-bg) !important;
      --bn-colors-hovered-text: var(--ghostty-fg) !important;
      --bn-colors-hovered-background: var(--ghostty-hover-bg) !important;
      --bn-colors-selected-text: var(--ghostty-bg) !important;
      --bn-colors-selected-background: var(--ghostty-fg) !important;
      --bn-colors-disabled-text: var(--ghostty-dim) !important;
      --bn-colors-disabled-background: var(--ghostty-menu-bg) !important;
    }
    body.ghostty-themed .bn-side-menu,
    body.ghostty-themed .bn-drag-handle-menu {
      color: var(--ghostty-dim) !important;
    }

    /* ── Obsidian-style frontmatter properties panel ── */
    #frontmatter-panel {
      display: none;
      margin: 8px 54px 0;
      padding: 10px 12px;
      border-radius: 8px;
      background: rgba(128, 128, 128, 0.06);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, sans-serif;
      font-size: 13px;
      line-height: 1.5;
    }
    #frontmatter-panel.visible { display: block; }

    .fm-header {
      display: flex;
      align-items: center;
      gap: 4px;
      padding-bottom: 4px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .fm-header-label {
      font-size: 12px;
      font-weight: 600;
      opacity: 0.5;
    }
    .fm-chevron {
      font-size: 10px;
      opacity: 0.4;
      transition: transform 0.15s ease;
    }
    .fm-header:hover .fm-header-label,
    .fm-header:hover .fm-chevron { opacity: 0.8; }
    .fm-collapsed .fm-chevron { transform: rotate(-90deg); }
    .fm-collapsed .fm-body { display: none; }

    .fm-body { padding-top: 2px; }

    .fm-row {
      display: flex;
      align-items: baseline;
      padding: 2px 0;
      gap: 12px;
    }
    .fm-row + .fm-row {
      border-top: 1px solid rgba(128, 128, 128, 0.08);
    }

    .fm-key {
      min-width: 80px;
      flex-shrink: 0;
      font-size: 13px;
      opacity: 0.45;
      font-weight: 500;
    }
    .fm-value {
      font-size: 13px;
      opacity: 0.8;
      word-break: break-word;
    }

    /* Tag pills (for tags/categories arrays) */
    .fm-tag {
      display: inline-block;
      padding: 1px 8px;
      margin: 1px 4px 1px 0;
      border-radius: 4px;
      background: rgba(128, 128, 128, 0.1);
      font-size: 12px;
    }

    /* Ghostty theme overrides for frontmatter panel */
    body.ghostty-themed #frontmatter-panel {
      background: var(--ghostty-hover-bg);
      color: var(--ghostty-fg);
    }
    body.ghostty-themed .fm-tag {
      background: rgba(128, 128, 128, 0.15);
    }
  </style>
</head>
<body>
  <div id="editor-container">
    <div id="frontmatter-panel"></div>
    <div id="root"></div>
  </div>
  <div id="loading-indicator">Loading BlockNote...</div>

  <!-- Local bundle: React + BlockNote (no CDN dependency) -->
  <script src="blocknote-bundle.js"></script>

  <script>
    // Helper: safely post a message to the native host
    function postMessage(name, body) {
      try {
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[name]) {
          window.webkit.messageHandlers[name].postMessage(body);
        }
      } catch (e) {
        console.error('postMessage error:', name, e);
      }
    }

    var { React, createRoot, useCreateBlockNote, BlockNoteView } = window.__BN;
    var h = React.createElement;

    var editorInstance = null;
    var pendingMarkdown = null;
    var storedFrontmatter = null;
    var originalBodyMarkdown = null;

    // Strip YAML frontmatter before passing to BlockNote, store it for later.
    // Frontmatter must start at the very first character of the file.
    function extractFrontmatter(md) {
      var match = md.match(/^---[ \t]*\n([\s\S]*?)\n---[ \t]*(\n|$)/);
      if (match) {
        storedFrontmatter = match[0];
        renderFrontmatterPanel(match[1]);
        return md.slice(match[0].length);
      }
      storedFrontmatter = null;
      renderFrontmatterPanel(null);
      return md;
    }

    // Re-attach stored frontmatter to markdown output
    function prependFrontmatter(md) {
      if (!storedFrontmatter) return md;
      var sep = md.startsWith('\n') ? '' : '\n';
      return storedFrontmatter + sep + md;
    }

    // ── Frontmatter panel rendering ──

    // Tags-like keys that should render as pills
    var tagKeys = ['tags', 'tag', 'categories', 'category', 'keywords', 'aliases'];

    // Parse simple YAML into [{key, value}] — handles scalars, inline arrays, list arrays
    function parseSimpleYaml(yaml) {
      var result = [];
      var lines = yaml.split('\n');
      var i = 0;
      while (i < lines.length) {
        var line = lines[i];
        var m = line.match(/^([\w][\w\s-]*?):\s*(.*)/);
        if (m) {
          var key = m[1].trim();
          var val = m[2].trim();
          // Inline array: key: [a, b, c]
          if (val.startsWith('[') && val.endsWith(']')) {
            val = val.slice(1, -1).split(',').map(function(s) { return s.trim(); });
          }
          // Multi-line list array
          else if (val === '') {
            var items = [];
            while (i + 1 < lines.length && /^\s+-\s+/.test(lines[i + 1])) {
              i++;
              items.push(lines[i].replace(/^\s+-\s+/, '').trim());
            }
            if (items.length > 0) val = items;
          }
          result.push({ key: key, value: val });
        }
        i++;
      }
      return result;
    }

    function renderFrontmatterPanel(yamlContent) {
      var panel = document.getElementById('frontmatter-panel');
      if (!yamlContent) {
        panel.classList.remove('visible');
        panel.innerHTML = '';
        return;
      }

      var props = parseSimpleYaml(yamlContent);
      if (props.length === 0) {
        panel.classList.remove('visible');
        panel.innerHTML = '';
        return;
      }

      var html = '<div class="fm-header" onclick="this.parentElement.classList.toggle(\'fm-collapsed\')">';
      html += '<span class="fm-chevron">&#9662;</span>';
      html += '<span class="fm-header-label">Properties</span>';
      html += '</div>';
      html += '<div class="fm-body">';

      for (var i = 0; i < props.length; i++) {
        var p = props[i];
        var isTag = tagKeys.indexOf(p.key.toLowerCase()) !== -1;
        html += '<div class="fm-row">';
        html += '<span class="fm-key">' + escapeHtml(p.key) + '</span>';

        if (Array.isArray(p.value) && isTag) {
          html += '<span class="fm-value">';
          for (var j = 0; j < p.value.length; j++) {
            html += '<span class="fm-tag">' + escapeHtml(p.value[j]) + '</span>';
          }
          html += '</span>';
        } else if (Array.isArray(p.value)) {
          html += '<span class="fm-value">' + escapeHtml(p.value.join(', ')) + '</span>';
        } else {
          html += '<span class="fm-value">' + escapeHtml(String(p.value)) + '</span>';
        }

        html += '</div>';
      }

      html += '</div>';
      panel.innerHTML = html;
      panel.classList.add('visible');
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // JS Bridge: called from Swift to set markdown content
    window.setMarkdown = async function(text) {
      var body = extractFrontmatter(text);
      originalBodyMarkdown = body;
      if (editorInstance) {
        var blocks = await editorInstance.tryParseMarkdownToBlocks(body);
        editorInstance.replaceBlocks(editorInstance.document, blocks);
      } else {
        pendingMarkdown = body;
      }
    };

    // JS Bridge: called from Swift to get current content as markdown
    window.getMarkdown = async function() {
      if (editorInstance) {
        var bnOutput = normalizeMarkdown(await editorInstance.blocksToMarkdownLossy(editorInstance.document));
        var merged = mergeWithOriginal(originalBodyMarkdown, bnOutput);
        originalBodyMarkdown = merged;
        return prependFrontmatter(merged);
      }
      return '';
    };

    // Normalize markdown output from BlockNote's blocksToMarkdownLossy():
    // - Restore '-' list markers (BlockNote defaults to '*')
    // - Remove trailing '\' hard-break markers inserted on soft breaks
    // Skips content inside fenced code blocks to avoid false matches.
    function normalizeMarkdown(md) {
      var lines = md.split('\n');
      var inCodeBlock = false;
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (/^(`{3,}|~{3,})/.test(line.trimStart())) {
          inCodeBlock = !inCodeBlock;
          continue;
        }
        if (inCodeBlock) continue;
        // Replace '* ' list marker with '- ' (skip thematic breaks like '* * *')
        if (/^(\s*)\* /.test(line) && !/^\s*(\*\s*){3,}$/.test(line)) {
          lines[i] = line.replace(/^(\s*)\* /, '$1- ');
        }
        // Remove trailing '\' hard-break marker (odd count only — even = escaped pairs)
        var trailingMatch = lines[i].match(/\\+$/);
        if (trailingMatch && trailingMatch[0].length % 2 === 1) {
          lines[i] = lines[i].slice(0, -1).trimEnd();
        }
      }
      return lines.join('\n');
    }

    // ── Original-preserving merge (diff-based round-trip fidelity) ──

    // Split markdown into logical blocks (separated by blank lines).
    // Respects fenced code blocks so internal blank lines don't cause splits.
    // Returns { blocks: [string], gaps: [string], trailing: string }
    //   gaps[i] = exact separator text between blocks[i] and blocks[i+1]
    //   trailing = text after the last block (preserves trailing newlines)
    function splitMarkdownBlocks(md) {
      if (!md) return { blocks: [], gaps: [], trailing: '' };
      var lines = md.split('\n');
      var blocks = [];
      var current = [];
      var inCodeBlock = false;
      for (var i = 0; i < lines.length; i++) {
        if (/^(`{3,}|~{3,})/.test(lines[i].trimStart())) {
          inCodeBlock = !inCodeBlock;
          current.push(lines[i]);
          continue;
        }
        if (!inCodeBlock && lines[i].trim() === '') {
          if (current.length > 0) {
            blocks.push(current.join('\n'));
            current = [];
          }
        } else {
          current.push(lines[i]);
        }
      }
      if (current.length > 0) {
        blocks.push(current.join('\n'));
      }
      // Extract exact gaps by locating each block's position in source text
      var gaps = [];
      var trailing = '';
      if (blocks.length > 0) {
        var searchFrom = 0;
        var prevEnd = 0;
        for (var i = 0; i < blocks.length; i++) {
          var pos = md.indexOf(blocks[i], searchFrom);
          if (i > 0) gaps.push(md.substring(prevEnd, pos));
          prevEnd = pos + blocks[i].length;
          searchFrom = prevEnd;
        }
        trailing = md.substring(prevEnd);
      }
      return { blocks: blocks, gaps: gaps, trailing: trailing };
    }

    // Extract plain-text fingerprint from a markdown block (strip all formatting).
    function textFingerprint(block) {
      var t = block;
      t = t.replace(/^(`{3,}|~{3,}).*$/gm, '');          // code fence markers
      t = t.replace(/^>\s*/gm, '');                         // blockquote markers
      t = t.replace(/^#{1,6}\s+/gm, '');                    // heading markers
      t = t.replace(/^(\s*)([-*+]|\d+\.)\s+/gm, '$1');      // list markers
      t = t.replace(/!\[([^\]]*)\]\([^)]*\)/g, '$1');        // images
      t = t.replace(/\[([^\]]*)\]\([^)]*\)/g, '$1');         // links
      t = t.replace(/(\*{1,3}|_{1,3}|~~)(.*?)\1/g, '$2');   // bold/italic/strike
      t = t.replace(/`([^`]*)`/g, '$1');                     // inline code
      t = t.replace(/\s+/g, ' ').trim();
      return t.toLowerCase();
    }

    // Longest Common Subsequence of two fingerprint arrays.
    // Returns array of { origIdx, bnIdx } matched pairs.
    function computeLCS(a, b) {
      var m = a.length, n = b.length;
      var dp = [];
      for (var i = 0; i <= m; i++) {
        dp[i] = new Array(n + 1);
        for (var j = 0; j <= n; j++) {
          if (i === 0 || j === 0) dp[i][j] = 0;
          else if (a[i-1] === b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
          else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        }
      }
      var matches = [];
      var i = m, j = n;
      while (i > 0 && j > 0) {
        if (a[i-1] === b[j-1]) {
          matches.unshift({ origIdx: i-1, bnIdx: j-1 });
          i--; j--;
        } else if (dp[i-1][j] > dp[i][j-1]) {
          i--;
        } else {
          j--;
        }
      }
      return matches;
    }

    // Merge BlockNote output with original markdown, preserving original text
    // for blocks whose plain-text content hasn't changed.
    // Also preserves original inter-block gaps when adjacent blocks are both from original.
    function mergeWithOriginal(original, bnOutput) {
      if (!original) return bnOutput;
      var origResult = splitMarkdownBlocks(original);
      var bnResult = splitMarkdownBlocks(bnOutput);
      if (origResult.blocks.length === 0) return bnOutput;
      if (bnResult.blocks.length === 0) return bnOutput;

      var origFP = origResult.blocks.map(textFingerprint);
      var bnFP = bnResult.blocks.map(textFingerprint);
      var matches = computeLCS(origFP, bnFP);

      var bnToOrig = {};
      for (var k = 0; k < matches.length; k++) {
        bnToOrig[matches[k].bnIdx] = matches[k].origIdx;
      }

      var parts = [];
      for (var i = 0; i < bnResult.blocks.length; i++) {
        // Insert gap before this block (except before the first)
        if (i > 0) {
          var prevOrig = bnToOrig.hasOwnProperty(i - 1) ? bnToOrig[i - 1] : -1;
          var currOrig = bnToOrig.hasOwnProperty(i) ? bnToOrig[i] : -1;
          if (prevOrig >= 0 && currOrig >= 0 && currOrig === prevOrig + 1) {
            // Both adjacent blocks from consecutive original positions — use original gap
            parts.push(origResult.gaps[prevOrig]);
          } else {
            parts.push('\n\n');
          }
        }
        if (bnToOrig.hasOwnProperty(i)) {
          parts.push(origResult.blocks[bnToOrig[i]]);
        } else {
          parts.push(bnResult.blocks[i]);
        }
      }

      var merged = parts.join('');
      // Preserve trailing whitespace from original (e.g. final newline)
      if (origResult.trailing) {
        merged += origResult.trailing;
      }
      return merged;
    }

    // Helper: determine if a hex color is "light" by computing relative luminance
    function hexIsLight(hex) {
      var r = parseInt(hex.slice(1, 3), 16) / 255;
      var g = parseInt(hex.slice(3, 5), 16) / 255;
      var b = parseInt(hex.slice(5, 7), 16) / 255;
      return (0.2126 * r + 0.7152 * g + 0.0722 * b) > 0.5;
    }

    // Helper: lighten or darken a hex color by a factor
    function adjustColor(hex, factor) {
      var r = parseInt(hex.slice(1, 3), 16);
      var g = parseInt(hex.slice(3, 5), 16);
      var b = parseInt(hex.slice(5, 7), 16);
      if (factor > 0) {
        r = Math.min(255, Math.round(r + (255 - r) * factor));
        g = Math.min(255, Math.round(g + (255 - g) * factor));
        b = Math.min(255, Math.round(b + (255 - b) * factor));
      } else {
        r = Math.max(0, Math.round(r * (1 + factor)));
        g = Math.max(0, Math.round(g * (1 + factor)));
        b = Math.max(0, Math.round(b * (1 + factor)));
      }
      return '#' + [r, g, b].map(function(c) { return c.toString(16).padStart(2, '0'); }).join('');
    }

    // Global API: Apply Ghostty terminal configuration (font size + theme).
    window._ghosttyTheme = null;

    window.applyGhosttyConfig = function(fontSize, fontFamily, bgColor, fgColor) {
      var isLight = hexIsLight(bgColor);
      var menuBg = isLight ? adjustColor(bgColor, -0.06) : adjustColor(bgColor, 0.12);
      var hoverBg = isLight ? adjustColor(bgColor, -0.1) : adjustColor(bgColor, 0.18);
      var dimColor = isLight ? adjustColor(fgColor, 0.5) : adjustColor(fgColor, -0.4);

      document.body.style.setProperty('--ghostty-bg', bgColor);
      document.body.style.setProperty('--ghostty-fg', fgColor);
      document.body.style.setProperty('--ghostty-menu-bg', menuBg);
      document.body.style.setProperty('--ghostty-hover-bg', hoverBg);
      document.body.style.setProperty('--ghostty-dim', dimColor);
      document.body.classList.add('ghostty-themed');

      // Set BlockNote's color-scheme attribute to match
      var container = document.querySelector('.bn-container');
      if (container) {
        container.setAttribute('data-color-scheme', isLight ? 'light' : 'dark');
      }

      // Apply font size from Ghostty config
      if (fontSize) {
        document.querySelector('.bn-editor').style.fontSize = fontSize + 'px';
      }

      // Store theme for React re-render
      window._ghosttyTheme = isLight ? 'light' : 'dark';
      if (window._setTheme) window._setTheme(window._ghosttyTheme);
    };

    // Keyboard shortcuts: Cmd+S → save, Cmd+E → switch to Monaco mode
    document.addEventListener('keydown', async function(e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 's') {
        e.preventDefault();
        var md = await window.getMarkdown();
        postMessage('save', { content: md });
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'e') {
        e.preventDefault();
        var md = await window.getMarkdown();
        postMessage('switchMode', { content: md });
      }
    });

    // Signal readiness to Swift
    postMessage('ready', true);

    // Mount BlockNote React app
    function App() {
      var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      var initialTheme = window._ghosttyTheme || (prefersDark ? 'dark' : 'light');
      var themeState = React.useState(initialTheme);
      var theme = themeState[0];
      var setTheme = themeState[1];

      // Expose setter so applyGhosttyConfig can trigger re-render
      window._setTheme = setTheme;

      var editor = useCreateBlockNote();

      React.useEffect(function() {
        editorInstance = editor;
        if (pendingMarkdown !== null) {
          window.setMarkdown(pendingMarkdown);
          pendingMarkdown = null;
        }
      }, [editor]);

      return h(BlockNoteView, { editor: editor, theme: theme });
    }

    document.getElementById('loading-indicator').style.display = 'none';
    var root = createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>
