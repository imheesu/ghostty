<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="blocknote-bundle.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    #root { width: 100%; height: 100%; overflow-y: auto; }
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #888;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
    }

    /* Notion-style typography overrides */
    .bn-container {
      --bn-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
    }

    .bn-editor {
      font-size: 14px;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    /* Heading sizes: compact Notion-like scale */
    [data-content-type=heading]                 { --level: 1.6em !important; }
    [data-content-type=heading][data-level="2"] { --level: 1.45em !important; }
    [data-content-type=heading][data-level="3"] { --level: 1.25em !important; }
    [data-content-type=heading][data-level="4"] { --level: 1em !important; }
    [data-content-type=heading][data-level="5"] { --level: 0.95em !important; }
    [data-content-type=heading][data-level="6"] { --level: 0.875em !important; }

    /* Tighter heading line-height */
    .bn-block-content[data-content-type=heading] {
      line-height: 1.3;
      letter-spacing: -0.01em;
    }

    /* Side menu heights to match smaller headings */
    .bn-side-menu[data-block-type=heading][data-level="1"] { height: 36px !important; }
    .bn-side-menu[data-block-type=heading][data-level="2"] { height: 30px !important; }
    .bn-side-menu[data-block-type=heading][data-level="3"] { height: 26px !important; }

    /* Ghostty theme integration: background/text sync */
    body.ghostty-themed { background: var(--ghostty-bg); color: var(--ghostty-fg); }
    body.ghostty-themed .bn-container {
      --bn-colors-editor-text: var(--ghostty-fg) !important;
      --bn-colors-editor-background: var(--ghostty-bg) !important;
      --bn-colors-menu-text: var(--ghostty-fg) !important;
      --bn-colors-menu-background: var(--ghostty-menu-bg) !important;
      --bn-colors-tooltip-text: var(--ghostty-fg) !important;
      --bn-colors-tooltip-background: var(--ghostty-menu-bg) !important;
      --bn-colors-hovered-text: var(--ghostty-fg) !important;
      --bn-colors-hovered-background: var(--ghostty-hover-bg) !important;
      --bn-colors-selected-text: var(--ghostty-bg) !important;
      --bn-colors-selected-background: var(--ghostty-fg) !important;
      --bn-colors-disabled-text: var(--ghostty-dim) !important;
      --bn-colors-disabled-background: var(--ghostty-menu-bg) !important;
    }
    body.ghostty-themed .bn-side-menu,
    body.ghostty-themed .bn-drag-handle-menu {
      color: var(--ghostty-dim) !important;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="loading-indicator">Loading BlockNote...</div>

  <!-- Local bundle: React + BlockNote (no CDN dependency) -->
  <script src="blocknote-bundle.js"></script>

  <script>
    // Helper: safely post a message to the native host
    function postMessage(name, body) {
      try {
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[name]) {
          window.webkit.messageHandlers[name].postMessage(body);
        }
      } catch (e) {
        console.error('postMessage error:', name, e);
      }
    }

    var { React, createRoot, useCreateBlockNote, BlockNoteView } = window.__BN;
    var h = React.createElement;

    var editorInstance = null;
    var pendingMarkdown = null;
    var autoSaveTimer = null;
    var skipAutoSave = false;

    // JS Bridge: called from Swift to set markdown content
    window.setMarkdown = async function(text) {
      if (editorInstance) {
        skipAutoSave = true;
        var blocks = await editorInstance.tryParseMarkdownToBlocks(text);
        editorInstance.replaceBlocks(editorInstance.document, blocks);
        setTimeout(function() { skipAutoSave = false; }, 200);
      } else {
        pendingMarkdown = text;
      }
    };

    // JS Bridge: called from Swift to get current content as markdown
    window.getMarkdown = async function() {
      if (editorInstance) {
        return normalizeMarkdown(await editorInstance.blocksToMarkdownLossy(editorInstance.document));
      }
      return '';
    };

    // Normalize markdown output from BlockNote's blocksToMarkdownLossy():
    // - Restore '-' list markers (BlockNote defaults to '*')
    // - Remove trailing '\' hard-break markers inserted on soft breaks
    // Skips content inside fenced code blocks to avoid false matches.
    function normalizeMarkdown(md) {
      var lines = md.split('\n');
      var inCodeBlock = false;
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (/^(`{3,}|~{3,})/.test(line.trimStart())) {
          inCodeBlock = !inCodeBlock;
          continue;
        }
        if (inCodeBlock) continue;
        // Replace '* ' list marker with '- ' (skip thematic breaks like '* * *')
        if (/^(\s*)\* /.test(line) && !/^\s*(\*\s*){3,}$/.test(line)) {
          lines[i] = line.replace(/^(\s*)\* /, '$1- ');
        }
        // Remove trailing '\' hard-break marker (odd count only — even = escaped pairs)
        var trailingMatch = lines[i].match(/\\+$/);
        if (trailingMatch && trailingMatch[0].length % 2 === 1) {
          lines[i] = lines[i].slice(0, -1).trimEnd();
        }
      }
      return lines.join('\n');
    }

    // Helper: determine if a hex color is "light" by computing relative luminance
    function hexIsLight(hex) {
      var r = parseInt(hex.slice(1, 3), 16) / 255;
      var g = parseInt(hex.slice(3, 5), 16) / 255;
      var b = parseInt(hex.slice(5, 7), 16) / 255;
      return (0.2126 * r + 0.7152 * g + 0.0722 * b) > 0.5;
    }

    // Helper: lighten or darken a hex color by a factor
    function adjustColor(hex, factor) {
      var r = parseInt(hex.slice(1, 3), 16);
      var g = parseInt(hex.slice(3, 5), 16);
      var b = parseInt(hex.slice(5, 7), 16);
      if (factor > 0) {
        r = Math.min(255, Math.round(r + (255 - r) * factor));
        g = Math.min(255, Math.round(g + (255 - g) * factor));
        b = Math.min(255, Math.round(b + (255 - b) * factor));
      } else {
        r = Math.max(0, Math.round(r * (1 + factor)));
        g = Math.max(0, Math.round(g * (1 + factor)));
        b = Math.max(0, Math.round(b * (1 + factor)));
      }
      return '#' + [r, g, b].map(function(c) { return c.toString(16).padStart(2, '0'); }).join('');
    }

    // Global API: Apply Ghostty terminal configuration (font size + theme).
    window._ghosttyTheme = null;

    window.applyGhosttyConfig = function(fontSize, fontFamily, bgColor, fgColor) {
      var isLight = hexIsLight(bgColor);
      var menuBg = isLight ? adjustColor(bgColor, -0.06) : adjustColor(bgColor, 0.12);
      var hoverBg = isLight ? adjustColor(bgColor, -0.1) : adjustColor(bgColor, 0.18);
      var dimColor = isLight ? adjustColor(fgColor, 0.5) : adjustColor(fgColor, -0.4);

      document.body.style.setProperty('--ghostty-bg', bgColor);
      document.body.style.setProperty('--ghostty-fg', fgColor);
      document.body.style.setProperty('--ghostty-menu-bg', menuBg);
      document.body.style.setProperty('--ghostty-hover-bg', hoverBg);
      document.body.style.setProperty('--ghostty-dim', dimColor);
      document.body.classList.add('ghostty-themed');

      // Set BlockNote's color-scheme attribute to match
      var container = document.querySelector('.bn-container');
      if (container) {
        container.setAttribute('data-color-scheme', isLight ? 'light' : 'dark');
      }

      // Apply font size from Ghostty config
      if (fontSize) {
        document.querySelector('.bn-editor').style.fontSize = fontSize + 'px';
      }

      // Store theme for React re-render
      window._ghosttyTheme = isLight ? 'light' : 'dark';
      if (window._setTheme) window._setTheme(window._ghosttyTheme);
    };

    // Keyboard shortcuts: Cmd+S → save, Cmd+E → switch to Monaco mode
    document.addEventListener('keydown', async function(e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 's') {
        e.preventDefault();
        var md = await window.getMarkdown();
        postMessage('save', { content: md });
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'e') {
        e.preventDefault();
        var md = await window.getMarkdown();
        postMessage('switchMode', { content: md });
      }
    });

    // Signal readiness to Swift
    postMessage('ready', true);

    // Mount BlockNote React app
    function App() {
      var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      var initialTheme = window._ghosttyTheme || (prefersDark ? 'dark' : 'light');
      var themeState = React.useState(initialTheme);
      var theme = themeState[0];
      var setTheme = themeState[1];

      // Expose setter so applyGhosttyConfig can trigger re-render
      window._setTheme = setTheme;

      var editor = useCreateBlockNote();

      React.useEffect(function() {
        editorInstance = editor;
        if (pendingMarkdown !== null) {
          window.setMarkdown(pendingMarkdown);
          pendingMarkdown = null;
        }
      }, [editor]);

      var handleChange = React.useCallback(function() {
        if (skipAutoSave) return;
        if (autoSaveTimer) clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(async function() {
          var md = await window.getMarkdown();
          postMessage('autoSave', { content: md });
        }, 1000);
      }, []);

      return h(BlockNoteView, { editor: editor, theme: theme, onChange: handleChange });
    }

    document.getElementById('loading-indicator').style.display = 'none';
    var root = createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>
